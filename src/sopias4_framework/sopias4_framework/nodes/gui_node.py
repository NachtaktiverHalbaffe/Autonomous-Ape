import abc
from threading import Event, Thread

import rclpy
from PyQt5.QtWidgets import QMainWindow, QMessageBox
from rclpy.client import Client
from rclpy.node import Node

from sopias4_framework.srv import Register, ShowDialog


class GUINode(QMainWindow):
    """
    This class is a Base GUI class which can be used to building a own GUI in the Sopias4 project. This class handles the QT GUI portion of the Node, the ROS2 Node itself 
    is a class attribute (node) which is instantiated by this class and runs under the hood in another object/Thread.

    For generating a GUI, create a UI file with QT Designer with which you can design the GUI graphically. For this purpose, you can run `designer` in the terminal to open 
    QT-Designer from the Dev-Container environment, otherwise you can install it on your host OS and use it there. After that, save the UI-File in the assets folder in Sopias4 
    Application and run the script `python3 generate_ui.py -i <path to ui file> -o <path to directory where the generated Python class should be saved>` which converts it to a 
    Python class. The script is located in `sopias4_framework/tools/scripts` in this ROS2-package. After that, you can inherit from the GUI Node and do the necessary steps:

    .. highlight:: python
    .. code-block:: python

            class YourImplementationClass(GUINode):

                def __init__(self) ->None:
                    # The script should name the Python object this way, but can vary. Doublecheck the class name
                    # within the generated Python file to be sure
                    ui_file = Ui_MainWindow() 
                    super().__init(self, ui_file)

                def connect_callbacks(self):
                    # You need to overrride this method. Connect your UI elements with the callacks here.
                    # The ui elements are in self.ui field of the GUINode class
                    self.ui.example_button.clicked.connect(self.__foobar)

                def set_default_values(self):
                    # You need to override this method. Set default values or default choices of your ui elements here
                    self.ui.example_textbox.setText("Hello World")

                def __foobar():
                    print("Hello World!")


    Following methods needs to be overriden (look further into documentation for more details):
        - connect_callbacks()
        - set_default_values()
    
    It also has builtin methods which you can use a callback functionas for certain tasks in Sopias4 (look further into documentation for more details):
        - register_namespace(): Register namespace in Sopias4 Map-Server

    It provides following ROS2-services:
        - show_dialog: Show a dialog with the users. Also interaction options can be specified

    Attributes:
            ui (Ui_MainWindow()): The Python UI Object which is generated by PyQt5. Should normally be a Ui_MainWindow() instance if using the provided scripts.\
            node_name (str, optional): Name of the Node. Defaults to gui_node
            namespace (str, optional): The namespace of the node. It should not be specified by the developer. Instead the User should use the register service and \
                                                        let the service set the namespace of this class. Defaults to None
    """

    def __init__(self, ui, node_name : str ="gui_node", namespace:str | None = None) -> None:
        # General setup
        super().__init__()
        # Class attributes
        self.ui = ui
        self.node_name:str = node_name
        self.namespace: str |None = namespace
        self.node: GrapficalNode =GrapficalNode(node_name=node_name, namespace= namespace)
        # Private class attributes
        self.__restart_flag = Event()
        self.__nodeThread = Thread(target= self.__runNode, daemon=True)
  
        # Setup GUI
        self.ui.setupUi(self)
         # Connecting the ui elements with callbacks and set values        
        self.connect_callbacks()
        self.set_default_values()

        #Create underlying node
        rclpy.init()        # Run node in a seperate thread
        self.__nodeThread.start()


    @abc.abstractmethod
    def connect_callbacks(self) -> None:
        """
        Connect the callback functions from the QT UI elements here. Needs to be overridden

        Example:
            .. highlight:: python
            .. code-block:: python

                    def connect_callbacks(self):
                        # The ui elements are in self.ui field of the GUINode class
                        self.ui.example_button.clicked.connect(self.hello_world)

        """

    @abc.abstractmethod
    def set_default_values(self) -> None:
        """
        Set the default values from the QT UI elements here. Needs to be overridden

        Example:
            .. highlight:: python
            .. code-block:: python

                  def set_default_values(self):
                    # Set default values or default choices of your ui elements here
                    self.ui.example_textbox.setText("Hello World")
        """

    def register_namespace(self, namespace:str):
        """
        Runs the service to create a namespace. It's basically a wrapper and calling the register_namespace 
        service client in the underlying node object. If successful, it will restart `self.node` with the namespace.
        This must be done before connecting to the Turtlebot. 
        
        Under normal circumstances, you use this as an callback to connect to Ui element when it is e.g. pressed

        Args:
            namespace (str): The namespace which should be registered
        """
        try:
           if self.node.register_namespace(namespace):
                self.namespace = namespace
                # Set restart flag so GUI recognizes the node shutdown as intentional and doesn't close
                self.__restart_flag.set()
           else:
               return
        except Exception as e:
            self.node.get_logger().error(f"Couldnt register name space: {e}")
        
        # Restart node with namespace
        self.node.destroy_node()
        self.node = GrapficalNode(node_name=self.node_name, namespace=self.namespace)
        self.__nodeThread = Thread(target=self.__runNode, daemon=True)
        self.__nodeThread.start()

    def closeEvent(self, event):
        """
        Executes when the GUI is closed

        :meta private:
        """
        self.node.destroy_node()
        rclpy.shutdown()
        event.accept()
    
    def __runNode(self):
        while rclpy.ok():  
            rclpy.spin_once(self.node)

        # Close gui when Node doesn't spin anymore and node wasn't shutdown intentionally 
        if not self.__restart_flag.is_set():
            self.close()

class GrapficalNode(Node):
    """
    This is the ROS2 Node which runs under the hood in the GUI. To avoid problems by multiple inheritance etc, \
    the node is done in this separate class which is instantiated as a attribute in the GUI. As a result, this class only
    handles the ROS2 Node specific stuff e.b. implementing services, actions, messages etc.

    Attributes:
        node_name (str): (optional) Name of the Node. Defaults to gui_node
        namespace (str): (optional) The namespace of the node. When not specified, the GUI has to register itself.\
                                    The namespace should not be set by the developer but instead let the register_namespace service set the namespace
    """
       
    def __init__(self,  node_name : str ="gui_node", namespace:str | None = None) -> None:
        if namespace is not None:
            super().__init__(node_name, namespace=namespace) # type: ignore
        else:
            super().__init__(node_name) # type: ignore

        # ---- Setup services -----
        self.show_dialog_service = self.create_service(
            ShowDialog, "show_dialog", self.__show_dialog
        )

        # --- Setup service clients ---
        self.mrc_client_register: Client = self.create_client(Register, "register_namespace")


    def register_namespace(self, namespace:str):
        """
        Runs a service client to register the namespace in Sopias4 Map-Server. 
        On Failure, the user is informed and has a choice to retry

        Args:
            namespace (str): The namespace which should be registered
        
        Returns:
            bool: If namespace was registered successfully or not
        """
        request: Register.Request = Register.Request()
        request.namespace_canditate = namespace
        future = self.mrc_client_register.call_async(request)

        # Make sure the node itself is spinnig
        while rclpy.ok():
            if future.done():
                try:
                    if future.result() == Register.Response.SUCCESS:
                        return True
                    else:
                        # Inform user about error
                        msg_2_user = ShowDialog.Request()
                        msg_2_user.title = "Error while registering namespace"
                        msg_2_user.icon = ShowDialog.Request.ICON_ERROR

                        match future.result():
                            case Register.Response.COLLISION_ERROR:
                                msg_2_user.content = "Namespace is already registered. Choose another one"
                                msg_2_user.interaction_options = ShowDialog.Request.CONFIRM
                            case Register.Response.ILLEGAL_NAMESPACE_ERROR:
                                msg_2_user.content = "Namespace contains illegal characters. Choose another one"
                                msg_2_user.interaction_options = ShowDialog.Request.CONFIRM
                            case Register.Response.UNKOWN_ERROR:
                                msg_2_user.content = "Unknown error occured"
                                msg_2_user.interaction_options = ShowDialog.Request.CONFIRM_RETRY

                        user_response = self.__show_dialog(msg_2_user, ShowDialog.Response())

                        # If user response is to retry, then recursively call this function, otherwise return False
                        if user_response.selected_option == ShowDialog.Response.CONFIRMED:
                            return False
                        elif user_response.selected_option == ShowDialog.Response.RETRY:
                            return self.register_namespace(namespace)
                        else:
                            return False
                except Exception as e:
                    raise e

        return False

    def __show_dialog(self, request_data: ShowDialog.Request, response_data: ShowDialog.Response) -> ShowDialog.Response:
        """Callback function for the show_dialog service. It creates a QT dialog, fills it with the values from the service request and shows it.
        Afterwards, if specified it returns the input from the user.

        Args:
            request_data (ShowDialog.Request): The data from the request. Look at service definition in srv/ShowDialog.srv
            reponse_data (ShowDialog.Response):  A response object into which the data for the response is written. Look at service definition in srv/ShowDialog.srv

        Returns:
            ShowDialog.Response: It returns response_data in which contains the selected option from the user input
        
        Raises:
            ValueError: If theres invalid data in the response
            NotImplementedError: If the user chooses a interaction option which isn't specified in the service response
        """
        dlg = QMessageBox()
        # Set static data that doesn't need validation
        dlg.setWindowTitle(request_data.title)
        dlg.setInformativeText(request_data.title)

        # Choose icon from set of QMessagebox icons
        match request_data.icon:
            case ShowDialog.Request.ICON_QUESTION:
                dlg.setIcon(QMessageBox.Question)
            case ShowDialog.Request.ICON_INFO:
                dlg.setIcon(QMessageBox.Information)
            case ShowDialog.Request.ICON_WARNING:
                dlg.setIcon(QMessageBox.Warning)
            case ShowDialog.Request.ICON_ERROR:
                dlg.setIcon(QMessageBox.Critical)
            case _:
                raise ValueError(
                    f"Specified icon: {request_data.icon} isn't implemented or has wrong value. \
                                Implemented icons: {ShowDialog.Request.ICON_QUESTION}, {ShowDialog.Request.ICON_INFO},\
                                {ShowDialog.Request.ICON_WARNING} and {ShowDialog.Request.ICON_ERROR}"
                )

        # Choose buttons which are displayed depending on the chosen interaction option in the request
        # The service supports the buttons which are defined as constants in the service definition (see srv/ShowDialog.srv)
        # PyQT support following buttons:  QMessageBox.Ok , QMessageBox.Open , QMessageBox.Save
        # QMessageBox.Cancel, QMessageBox.Close, QMessageBox.Yes, QMessageBox.No, QMessageBox.Abort
        # QMessageBox.Retry and QMessageBox.Ignore
        match request_data.interaction_options:
            case ShowDialog.Request.CONFIRM:
                dlg.setStandardButtons(QMessageBox.Ok)
            case ShowDialog.Request.CONFIRM_ABORT:
                dlg.setStandardButtons(QMessageBox.Abort | QMessageBox.Ok)
            case ShowDialog.Request.CONFIRM_RETRY:
                dlg.setStandardButtons(QMessageBox.Retry | QMessageBox.Ok)
            case ShowDialog.Request.CONFIRM_CANCEL:
                dlg.setStandardButtons(QMessageBox.Cancel | QMessageBox.Ok)
            case ShowDialog.Request.YES_NO:
                dlg.setStandardButtons(QMessageBox.No | QMessageBox.Yes)
            case ShowDialog.Request.IGNORE_CANCEL:
                dlg.setStandardButtons(QMessageBox.Ignore | QMessageBox.Cancel)
            case ShowDialog.Request.IGNORE_ABORT:
                dlg.setStandardButtons(QMessageBox.Ignore | QMessageBox.Abort)
            case  ShowDialog.Request.IGNORE_RETRY:
                dlg.setStandardButtons(QMessageBox.Ignore | QMessageBox.Retry)
            case _:
                raise ValueError(
                    f"Specified interaction option: {request_data.interaction_options} has isn't implemented \
                                    or has wrong value. Implemented icons: {ShowDialog.Request.CONFIRM}, {ShowDialog.Request.CONFIRM_ABORT} \
                                    {ShowDialog.Request.CONFIRM_CANCEL}, {ShowDialog.Request.CONFIRM_RETRY} and {ShowDialog.Request.YES_NO}"
                )

        # Show dialog and get the pressed button
        selected_option = dlg.exec()

        # Here we can look for each button, even if they werent displayed,
        # because we only want to know the pressed button so the ones that arent displayed are not selected
        match selected_option:
            case QMessageBox.Ok:
                response_data.selected_option = ShowDialog.Response.CONFIRMED
            case QMessageBox.ABORT:
                response_data.selected_option = ShowDialog.Response.ABORT
            case QMessageBox.Retry:
                response_data.selected_option = ShowDialog.Response.RETRY
            case QMessageBox.Yes:
                response_data.selected_option = ShowDialog.Response.YES
            case QMessageBox.No:
                response_data.selected_option = ShowDialog.Response.NO
            case QMessageBox.Ignore:
                response_data.selected_option = ShowDialog.Response.IGNORE
            case QMessageBox.Cancel:
                response_data.selected_option = ShowDialog.Response.CANCEL
            case _:
                raise NotImplementedError(
                    f"Dialog returned selected option: {selected_option} which is not\
                        implemented in ROS Service. Currently supported options are:\
                        QMessageBox.Ok, QMessageBox.Abort, QMessageBox.Retry, \
                        QMessageBox.Yes, QMessageBox.No, QMessageBox.Ignore and QMessageBox.Cancel"
                )

        return response_data
    

if __name__=="__main__":
    print("Only run this node directly for testing purposes. In production this node should be extendend properly")